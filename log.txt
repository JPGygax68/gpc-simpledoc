2015-06-24
==========

Lesson learned: an element that is marked content-editable will *capture* all keyboard input of contained elements, even if they are content-editable themselves. (At least on Chrome.)


2015-06-22
==========

The editor needs to keep track of where the selection (the caret) is within the document structure. This is required for probably more than one thing; right now, directing commands to the right handler (plugin) is what's on my mind.

-----------

New term: "proxy". Means the DOM element representing a document element.

Got an embryo for event handlers. Next task: detect and handle new paragraphs created by editing. (Right now, new paragraph proxies are being assigned neither a document element, nor a doc element type - the latter is needed however for the newly-introduced event handling).

2015-06-21
==========

Got "artificial" highlighting working as an experimental feature.

- Multiple block ? (highlighted in different colors ?)
- What about multiple level (e.g. chapter - paragraph) ?

2015-06-20
==========

Handling inline elements is a problem that needs to be solved. I'm starting to experiment with that now.


2015-06-16
==========

Thoughts on how to proceed.

A "document" can be and contain many and very different things. Because of that, any "Editor" needs to be carefully architectured so as to be extremely simple at its core, obtaining nearly all of its functionality via "plug-ins" or "pluggable components".

The basic idea is relatively simple: every node in the document tree is represented by a DOM element (or a branch of DOM elements, if a single element is not sufficient). The Editor components draws upon a registry that provides functional elements for every known node type.

"Juggling" these functional elements is the main task of the Editor component. The editor does not necessarily need to have the complete set of functional elements for every node type in order to be able to work on a document - some may be optional.

Functional elements could be:

- Converting the node (JS object) to a DOM representation
- Converting the DOM representation back to a document node
- Input filter to provide editing functionality

With such a plug-in based architecture, the complex task of editing documents could actually become not only doable, but fun. Discipline will be required to avoid going into too many directions at once.

Plug-ins could provide any number of functional elements, and might even compete among each other. 
... but also work with each other, by looking each other up to collaborate (might be a can of worms though).

Not sure about the following idea yet: hierarchical document node types ? With carefully crafted rules, functional elements could delegate work to other plug-ins without even knowing them, simply by telling the Editor that they are *not* consuming the event they received.

2015-06-09
==========

Updating the index via a roundtrip to the CouchDB server is slow. I'm not sure that's really relevant though: since the update happens asynchronously, the only problem is the user wondering why his change does not seem to affect the index - until it does.

Using PouchDB as a local cache might help. Of course, that will raise many questions about synchronization.

Without lightning-fast caching though, it would fall to the user interface to adequately communicate delays to the user. Also, care must be taken that a refresh can be aborted, and that it does not in any way make any part of the UI unusable, or tricks the user into making wrong clicks by changing the position of things while the user is interacting with them [to my knowledge, few UIs actually deal with this hazard, but it should be done regardless].


2015-06-08
==========

I have now re-engineered the "thing" and decided that what I'm displaying on the page is not a document, but an editor.

So now that I'm looking at this as a custom widget of sorts, things are starting to fall in place, especially regarding loading and saving documents (of which only the former works at this point: I can now do that via explicit code rather than try to have Knockout control the process.

A thought: maybe I should put SimpleDoc CSS code into a separate file  perhaps even (eventually) make it a separate package - from the CSS meant for the editor.

Another thought: this should probably become a Knockout "component" pretty soon.


2015-06-06
==========

- OMG. WebODF!!

2015-06-03
==========

- RESTful cookbook: http://restcookbook.com/HTTP%20Methods/put-vs-post/

--------

Today's accomplishment: saving documents, and getting an index; both via hand-coded routes, and with Cradle as a "middle man" and/or "facilitator".

I think there should be an NPM module for the repetitive part of a RESTful api. Not that it is long or difficult work, but in many cases, the only thing that changes is the class name of the objects contained in the collection, plus the plural form so that the collection can be properly named.

I think supporting Backbone and/or Knockback should be doable with minimal code on both the server and the client side.

2015-05-31
==========

- CAUTION: .gitignore contains dist/*, meaning that NPM will ignore it too by default ?

- TODO next: css-injector

2015-05-30
==========

It appears that I will have to intercept the RETURN key: Firefox does not create a new element (contrary to Chrome), but merely inserts a br element. Fixing this after it has happened would introduce a "twitchiness" that no one wants to see.

-----

Apparently, counting "input" events and "ctrl-z" occurrences is the only way to detect whether an undo should be left to the browser or handled by my code (and even that may well be unreliable (will the browser consider the "undo" as done or not when I cancel the ctrl-z keydown event?). I fear I will still have a way to work with this.

-----

Strange - after having almost completed paragraph splitting, it appears that it is not necessary after all. The problems earlier, including the browser differences, were apparently due to the fact that the initial document did not have a paragraph element.

This means that care must be taken to ensure that P elements are used where ever appropriate. In fact, this is related to all sorts of questions of how - or how not - to structure documents.

2015-05-29
==========

I did some experimenting with Knockout and contenteditable.

My assessment for the moment is that Knockout may be ill-suited to be the workhorse for a document editor (though it could still, and probably should, be made into a Knockout component at some point).

The reason is that contenteditable can do impressive things on its own. For example, appending a new paragraph to an existing one is something that requires no programming at all. But if one wanted to maintain a 1:1 relationship between Knockout view-models and P elements in the DOM, one would need to both intercept all the events leading to the creation of the new paragraph, which could be very difficult to do and still be very unreliable, and the do the exact same thing programmatically.

This means that it would probably be a better idea to let contenteditable do its thing without too much interference, with the code just sprinkling in its support to guide things and enforce a few rules in the interest of well-formedness.

This means that updating the model is something that has to be done programmatically as well. I'm not 100% sure at this point whether this should be an actual data model or a view-model, i.e. an intermediary. Since Knockout is ill-suited for free-style document editing, it would not be a Knockout view-model anyway. So I think I will define an actual data model, with JS objects in minds (but potentially adaptable/upgradeable to XML).

Updating said data model should happen in response to input events. For example, when the user presses the RETURN key, the browser will insert/append a new paragraph at the cursor position, meaning that it will be safe to store the paragraph it was previously in.

That should indeed be the modus operandi: let the browser do its thing (mostly), then update the data model from the DOM. In some cases, it may be necessary to delay the programmed reaction (via a 1ms timeout?); specifically, when the idea is to modify the DOM structure created/modified by the browser. Though it is my hope that things can be monitored with sufficient precision to make it possible to simply abort events, rather than trying to fix things after they're done.

Next step: create a Knockout custom binding called "GPC SimpleDocument", then implement that using jQuery. The first goal would be the ability to append/insert and delete paragraphs, and update a super-simple data model defined thus:

  - Document: [ Node ]
  - Node <- Paragraph
  - Node <- [ Node ]

Other node types will be added later.

Another idea would be to use the DOM itself as the "official" data model, and leave storing it to consumers. That does present a potential problem though in that the DOM will likely have to be annotated by the document editor for its own benefit, meaning that filtering would be necessary.

Yet another idea would be to use XSLT to load and store documents, implying the use of XML instead of JSON. In all likelihood though, JS code would be the easiest choice.